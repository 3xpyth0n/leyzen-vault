package internal

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"leyzenctl/internal/compose"
)

func GenerateConfig(stdout, stderr io.Writer, envFile string) error {
	resolvedEnvPath, err := ResolveEnvFilePath(envFile)
	if err != nil {
		return fmt.Errorf("failed to resolve env file path: %w", err)
	}

	env, err := loadEnvWithPriority(resolvedEnvPath)
	if err != nil {
		return fmt.Errorf("failed to load environment: %w", err)
	}

	webContainers, _ := resolveWebContainers(env)

	enableHTTPS := isTrue(env["ENABLE_HTTPS"])
	sslCertPath := env["SSL_CERT_PATH"]
	sslKeyPath := env["SSL_KEY_PATH"]

	httpPort := parsePort(env["HTTP_PORT"], 8080)
	httpsPort := parsePort(env["HTTPS_PORT"], 8443)

	fmt.Fprintln(stdout, "[compose] Leyzen Vault service")
	fmt.Fprintf(stdout, "[compose] Number of replicas: %d\n", len(webContainers))
	fmt.Fprintf(stdout, "[haproxy] HTTP port: %d:80\n", httpPort)
	if enableHTTPS {
		fmt.Fprintf(stdout, "[haproxy] HTTPS port: %d:443\n", httpsPort)
		fmt.Fprintln(stdout, "[haproxy] HTTPS: enabled")
		if sslCertPath != "" {
			fmt.Fprintf(stdout, "[haproxy] SSL certificate: %s\n", sslCertPath)
		}
	} else {
		fmt.Fprintln(stdout, "[haproxy] HTTPS: disabled")
	}

	var sslBundlePath string
	if enableHTTPS && sslCertPath != "" {
		repoRoot, err := FindRepoRoot()
		if err != nil {
			return err
		}

		bundlePath, warnings, err := compose.PrepareSSLCertificateBundle(
			enableHTTPS,
			sslCertPath,
			sslKeyPath,
			repoRoot,
			"",
		)
		if err != nil {
			return fmt.Errorf("failed to prepare SSL bundle: %w", err)
		}

		for _, w := range warnings {
			fmt.Fprintf(stdout, "[warning] %s\n", w)
		}

		if bundlePath != "" {
			sslBundlePath = bundlePath
			fmt.Fprintf(stdout, "[haproxy] SSL bundle: %s\n", sslBundlePath)
		}
	}

	orchestratorEnabled := isOrchestratorEnabled(env)

	var sslCertPathContainer string
	if enableHTTPS && sslCertPath != "" {
		sslCertPathContainer = "/usr/local/etc/haproxy/ssl/cert.pem"
	}

	haproxyConfig := compose.RenderHAProxyConfig(
		webContainers,
		compose.VaultWebPort,
		enableHTTPS,
		sslCertPathContainer,
		orchestratorEnabled,
	)

	repoRoot, err := FindRepoRoot()
	if err != nil {
		return err
	}

	haproxyPath := filepath.Join(repoRoot, "infra", "haproxy", "haproxy.cfg")
	if err := os.MkdirAll(filepath.Dir(haproxyPath), 0755); err != nil {
		return fmt.Errorf("failed to create haproxy config dir: %w", err)
	}
	if err := os.WriteFile(haproxyPath, []byte(haproxyConfig), 0644); err != nil {
		return fmt.Errorf("failed to write haproxy config: %w", err)
	}

	backendSummary := ""
	var backendList []string
	for _, name := range webContainers {
		backendList = append(backendList, fmt.Sprintf("%s:%d", name, compose.VaultWebPort))
	}
	backendSummary = strings.Join(backendList, ", ")

	fmt.Fprintf(stdout, "[haproxy] Generated config for Leyzen Vault (%d replica%s)\n", len(webContainers), pluralize(len(webContainers)))
	if backendSummary != "" {
		fmt.Fprintf(stdout, "[haproxy] Backends: %s\n", backendSummary)
	}

	manifestBytes, err := compose.BuildComposeManifest(env, webContainers, sslBundlePath, envFile)
	if err != nil {
		return fmt.Errorf("failed to build compose manifest: %w", err)
	}

	composePath := filepath.Join(repoRoot, "docker-generated.yml")
	header := `# ==================================================================================
# WARNING: This file is auto-generated by leyzenctl config generate
# Do NOT edit this file manually.
# ==================================================================================

`
	finalContent := append([]byte(header), manifestBytes...)
	if err := os.WriteFile(composePath, finalContent, 0644); err != nil {
		return fmt.Errorf("failed to write docker-generated.yml: %w", err)
	}
	fmt.Fprintf(stdout, "[compose] Wrote %s\n\n", composePath)

	return nil
}

func loadEnvWithPriority(envFile string) (map[string]string, error) {
	fileEnv, err := LoadEnvFile(envFile)
	if err != nil {
		return nil, err
	}

	envMap := make(map[string]string)

	for _, e := range os.Environ() {
		pair := strings.SplitN(e, "=", 2)
		if len(pair) == 2 {
			envMap[pair[0]] = pair[1]
		}
	}

	for _, entry := range fileEnv.Entries {
		if entry.IsPair {
			envMap[entry.Key] = entry.Value
		}
	}

	return envMap, nil
}

func resolveWebContainers(env map[string]string) ([]string, string) {
	if !isOrchestratorEnabled(env) {
		return []string{"vault_app"}, "vault_app"
	}

	if val := strings.TrimSpace(env["ORCH_WEB_CONTAINERS"]); val != "" {
		names := parseContainerNames(val)
		if len(names) > 0 {
			return names, val
		}
	}

	replicasRaw := env["WEB_REPLICAS"]
	replicas, _ := strconv.Atoi(replicasRaw)
	if replicas < compose.VaultMinReplicas {
		replicas = compose.VaultMinReplicas
		if replicasRaw == "" {
			replicas = 3
		}
		if replicas < 2 {
			replicas = 2
		}
	}

	var names []string
	for i := 0; i < replicas; i++ {
		names = append(names, fmt.Sprintf("vault_web%d", i+1))
	}
	return names, strings.Join(names, ",")
}

func parseContainerNames(val string) []string {
	fields := strings.FieldsFunc(val, func(r rune) bool {
		return r == ',' || r == ' '
	})
	var names []string
	seen := make(map[string]bool)
	for _, f := range fields {
		f = strings.TrimSpace(f)
		if f != "" && !seen[f] {
			names = append(names, f)
			seen[f] = true
		}
	}
	return names
}

func isOrchestratorEnabled(env map[string]string) bool {
	val := strings.ToLower(strings.TrimSpace(env["ORCHESTRATOR_ENABLED"]))
	if val == "" {
		return false
	}
	return val == "true" || val == "1" || val == "yes" || val == "on"
}

func isTrue(val string) bool {
	val = strings.ToLower(strings.TrimSpace(val))
	return val == "true" || val == "1" || val == "yes" || val == "on"
}

func parsePort(val string, def int) int {
	if val == "" {
		return def
	}
	i, err := strconv.Atoi(val)
	if err != nil {
		return def
	}
	if i < 1 || i > 65535 {
		return def
	}
	return i
}

func pluralize(count int) string {
	if count != 1 {
		return "s"
	}
	return ""
}
