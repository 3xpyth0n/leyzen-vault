"""HAProxy configuration helpers for Leyzen Vault."""

from __future__ import annotations

from typing import Mapping, Sequence


def resolve_backend_port(env: Mapping[str, str]) -> int:
    """Return the backend port for Leyzen Vault."""

    override = env.get("VAULT_WEB_PORT", "").strip()
    if override:
        try:
            port = int(override)
        except ValueError:
            port = None
        else:
            if port is not None and 1 <= port <= 65535:
                return port
    # Default port for Vault web services
    return 80


def _format_backend_servers(containers: Sequence[str], port: int) -> list[str]:
    lines: list[str] = []
    for name in containers:
        lines.append(f"    server {name} {name}:{port} check")
    if not lines:
        lines.append("    # No backend servers configured")
    return lines


def render_haproxy_config(
    containers: Sequence[str],
    port: int,
    *,
    enable_https: bool = False,
    ssl_cert_path: str | None = None,
) -> str:
    """Return the HAProxy configuration for Leyzen Vault.

    This function is kept for backward compatibility but delegates to render_haproxy_config_vault.

    Args:
        containers: List of container names for the backend servers.
        port: Backend port number.
        enable_https: If True, enable HTTPS frontend on port 443.
        ssl_cert_path: Path to SSL PEM file that contains both certificate and key.

    Returns:
        HAProxy configuration string.
    """
    return render_haproxy_config_vault(
        containers,
        port,
        enable_https=enable_https,
        ssl_cert_path=ssl_cert_path,
    )


def render_haproxy_config_vault(
    containers: Sequence[str],
    port: int,
    *,
    enable_https: bool = False,
    ssl_cert_path: str | None = None,
    orchestrator_enabled: bool = True,
) -> str:
    """Return the HAProxy configuration for Leyzen Vault.

    Args:
        containers: List of container names for the backend servers.
        port: Backend port number.
        enable_https: If True, enable HTTPS frontend on port 443.
        ssl_cert_path: Path to SSL PEM file that contains both certificate and key.
        orchestrator_enabled: If True, include orchestrator backend and routes.

    Returns:
        HAProxy configuration string.
    """
    backend_name = "vault_backend"
    server_lines = _format_backend_servers(containers, port)
    http_check_lines = [
        "    http-check send meth GET uri /healthz ver HTTP/1.1 hdr Host localhost",
        "    http-check expect status 200",
        '    http-check expect string "ok"',
    ]

    lines = [
        "# ==================================================================================",
        "# WARNING: This file is auto-generated by compose/haproxy_config.py",
        "# Do NOT edit this file manually. Instead, modify:",
        "#   - compose/haproxy_config.py for HAProxy configuration logic",
        "#   - compose/build.py for service generation",
        "#   - Then run: python compose/build.py",
        "# ==================================================================================",
        "",
        "global",
        "    log stdout format raw local0",
        "    maxconn 4096",
        "",
        "resolvers docker",
        "    nameserver dns1 127.0.0.11:53",
        "    resolve_retries       3",
        "    timeout resolve        1s",
        "    timeout retry          1s",
        "    hold valid            10s",
        "",
        "defaults",
        "    log     global",
        "    mode    http",
        "    option  dontlog-normal",
        "    option  dontlognull",
        "    default-server init-addr none resolvers docker",
        "    timeout connect 5s",
        "    timeout client  50s",
        "    timeout server  50s",
        "    timeout check 5s",
        "",
        "http-errors myerrors",
        "    errorfile 503 /usr/local/etc/haproxy/503.http",
        "    errorfile 404 /usr/local/etc/haproxy/404.http",
        "",
        "frontend http_front",
        "    bind *:80",
        "    errorfiles myerrors",
        "    # Don't intercept 404 for API routes (let Flask handle JSON responses)",
        "    http-request set-var(txn.is_api) bool(true) if { path_beg /api }",
        "    http-response return status 404 errorfile /usr/local/etc/haproxy/404.http if { status 404 } !{ var(txn.is_api) -m bool }",
        "    http-request set-header X-Forwarded-Proto https if { ssl_fc }",
        '    http-response set-header Strict-Transport-Security "max-age=31536000; includeSubDomains" if { ssl_fc }',
        '    http-response set-header X-Content-Type-Options "nosniff"',
        '    http-response set-header X-Frame-Options "DENY"',
        '    http-response set-header X-XSS-Protection "1; mode=block"',
        '    http-response set-header Referrer-Policy "strict-origin-when-cross-origin"',
        "",
    ]

    # Add orchestrator routes only if orchestrator is enabled
    if orchestrator_enabled:
        lines.extend(
            [
                "    acl path_orchestrator path_beg /orchestrator",
                "    use_backend orchestrator_backend if path_orchestrator",
                "",
            ]
        )

    lines.append(f"    default_backend {backend_name}")
    lines.append("")

    # Add HTTPS frontend if enabled
    if enable_https and ssl_cert_path:
        ssl_bind = f"    bind *:443 ssl crt {ssl_cert_path}"

        https_frontend_lines = [
            "# HTTPS frontend - SSL/TLS termination",
            "frontend https_front",
            ssl_bind,
            "    errorfiles myerrors",
            "    # Don't intercept 404 for API routes (let Flask handle JSON responses)",
            "    http-request set-var(txn.is_api) bool(true) if { path_beg /api }",
            "    http-response return status 404 errorfile /usr/local/etc/haproxy/404.http if { status 404 } !{ var(txn.is_api) -m bool }",
            "    http-request set-header X-Forwarded-Proto https",
            '    http-response set-header Strict-Transport-Security "max-age=31536000; includeSubDomains"',
            '    http-response set-header X-Content-Type-Options "nosniff"',
            '    http-response set-header X-Frame-Options "DENY"',
            '    http-response set-header X-XSS-Protection "1; mode=block"',
            '    http-response set-header Referrer-Policy "strict-origin-when-cross-origin"',
            "",
        ]

        # Add orchestrator routes only if orchestrator is enabled
        if orchestrator_enabled:
            https_frontend_lines.extend(
                [
                    "    acl path_orchestrator path_beg /orchestrator",
                    "    use_backend orchestrator_backend if path_orchestrator",
                    "",
                ]
            )

        https_frontend_lines.append(f"    default_backend {backend_name}")
        https_frontend_lines.append("")

        lines.extend(https_frontend_lines)

    lines.extend(
        [
            f"backend {backend_name}",
            "    balance roundrobin",
            "    option http-server-close",
            "    option forwardfor header X-Forwarded-For if-none",
            "    option redispatch",
            "    option allbackups",
            "    default-server resolvers docker init-addr none check inter 2s fall 2 rise 3",
            "    option httpchk",
        ]
    )
    lines.extend(http_check_lines)
    lines.extend(server_lines)

    # Add orchestrator backend only if orchestrator is enabled
    if orchestrator_enabled:
        lines.extend(
            [
                "",
                "backend orchestrator_backend",
                "    option http-server-close",
                "    option forwardfor header X-Forwarded-For if-none",
                "    default-server resolvers docker init-addr none check",
                "    server orchestrator orchestrator:80",
                "",
            ]
        )

    return "\n".join(lines) + "\n"


__all__ = [
    "render_haproxy_config",
    "resolve_backend_port",
    "render_haproxy_config_vault",
]
