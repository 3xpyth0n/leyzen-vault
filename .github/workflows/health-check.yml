name: Health Check

permissions:
  contents: read

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  health-check:
    name: Container health check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      COMPOSE_PROJECT_NAME: leyzen-vault-github-action-${{ github.run_id || format('local-{0}', github.run_attempt) }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Clean up action-specific Docker resources
        run: |
          PROJECT_PREFIX="leyzen-vault-github-action-"
          docker ps -a --format "{{.Names}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker rm -f 2>/dev/null || true
          docker volume ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker volume rm 2>/dev/null || true
          docker network ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker network rm 2>/dev/null || true

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r src/orchestrator/requirements.txt
          pip install -r infra/docker-proxy/requirements.txt

      - name: Create .env file with minimal configuration
        run: |
          # Remove any existing .env files that might interfere
          rm -f .env .env.health-check
          find . -maxdepth 2 -name ".env*" -type f -delete || true

          # Generate secrets
          SECRET_KEY=$(openssl rand -hex 32)
          POSTGRES_PASSWORD=$(openssl rand -hex 32)

          # Create health-check specific .env file with explicit name
          # This file will be referenced via LEYZEN_ENV_FILE to ensure isolation
          {
            echo "ORCHESTRATOR_ENABLED=true"
            echo "LEYZEN_ENVIRONMENT=dev"
            echo "ORCH_USER=test_user"
            echo "ORCH_PASS=test_pass"
            echo "HTTP_PORT=12345"
            echo "SECRET_KEY=${SECRET_KEY}"
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
            echo "WEB_REPLICAS=2"
            echo "TIMEZONE=UTC"
            echo "PROXY_TRUST_COUNT=1"
            echo "SESSION_COOKIE_SECURE=false"
            echo "POSTGRES_DB=leyzen_vault"
            echo "POSTGRES_USER=leyzen"
          } > .env.health-check

      - name: Generate docker-generated.yml
        run: |
          rm -f docker-generated.yml

          # Use LEYZEN_ENV_FILE to explicitly point to the health-check environment file
          # This ensures build.py uses the correct .env file and prevents production
          # environment variables from leaking into the test environment
          export LEYZEN_ENV_FILE=.env.health-check

          python src/compose/build.py

          if [ ! -f docker-generated.yml ]; then
            echo "‚ùå ERROR: docker-generated.yml was not created!"
            exit 1
          fi

          # Verify orchestrator is enabled (vault_app should NOT exist, vault_web1 should exist)
          if docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^vault_app$"; then
            echo "‚ùå ERROR: vault_app found (orchestrator appears to be disabled)"
            exit 1
          fi

          if ! docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^vault_web1$"; then
            echo "‚ùå ERROR: vault_web containers not found"
            exit 1
          fi

          if ! docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^orchestrator$"; then
            echo "‚ùå ERROR: orchestrator service not found"
            exit 1
          fi

      - name: Prefix volumes, networks, and containers with project name
        run: |
          python3 << PYEOF
          import re
          import os
          import sys

          yaml_file = "docker-generated.yml"
          project_prefix = os.environ.get("COMPOSE_PROJECT_NAME", "leyzen-vault-github-action") + "-"

          with open(yaml_file, 'r') as f:
              content = f.read()

          original_content = content

          # Prefix volume names (must match "leyzen-" pattern and not already be prefixed)
          # Only prefix volumes that start with "leyzen-" but don't already have the project prefix
          content = re.sub(
              r'(\s+name:\s+)"(leyzen-[^"]+)"',
              lambda m: f'{m.group(1)}"{project_prefix}{m.group(2)}"'
              if not m.group(2).startswith(project_prefix) else m.group(0),
              content
          )

          # Prefix container names (only if not already prefixed)
          content = re.sub(
              r'(\s+container_name:\s+)"([^"]+)"',
              lambda m: f'{m.group(1)}"{project_prefix}{m.group(2)}"'
              if not m.group(2).startswith(project_prefix) else m.group(0),
              content
          )

          # Prefix network names (must match "leyzen-" pattern and not already be prefixed)
          content = re.sub(
              r'(\s+name:\s+)"(leyzen-[^"]+)"',
              lambda m: f'{m.group(1)}"{project_prefix}{m.group(2)}"'
              if not m.group(2).startswith(project_prefix) else m.group(0),
              content
          )

          # Verify that all volumes starting with "leyzen-" were prefixed
          # This is a safety check to ensure we don't accidentally use production volumes
          # Only check for volumes that start with "leyzen-" but don't have the project prefix
          unprefixed_volumes = re.findall(r'(\s+name:\s+)"(leyzen-[^"]+)"', content)
          unprefixed_volumes = [
              match for match in unprefixed_volumes
              if not match[1].startswith(project_prefix)
          ]
          if unprefixed_volumes:
              print(f"‚ùå ERROR: Found {len(unprefixed_volumes)} unprefixed volumes:", file=sys.stderr)
              for match in unprefixed_volumes:
                  print(f"  - {match[1]}", file=sys.stderr)
              print("All volumes must be prefixed to prevent accidental deletion of production data!", file=sys.stderr)
              sys.exit(1)

          with open(yaml_file, 'w') as f:
              f.write(content)

          print(f"‚úÖ Successfully prefixed all volumes, networks, and containers with '{project_prefix}'")
          PYEOF

      - name: Build and start containers
        run: |
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" pull || true
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" build --no-cache
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" up -d

      - name: Wait for containers to become healthy
        run: |
          max_attempts=60
          attempt=0

          echo "Phase 1: Waiting for critical services to become healthy..."
          attempt=0
          all_critical_healthy=false

          while [ $attempt -lt $max_attempts ] && [ "$all_critical_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services)
            all_critical_healthy=true
            current_time=$(date +%s)

            for service in $services; do
              if [ "$service" = "orchestrator" ]; then
                continue
              fi

              container_name=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q $service 2>/dev/null | head -n1)
              if [ -z "$container_name" ]; then
                if [[ ! "$service" =~ ^vault_web ]]; then
                  all_critical_healthy=false
                fi
                continue
              fi

              status=$(docker inspect --format='{{.State.Status}}' $container_name 2>/dev/null || echo "unknown")
              health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $container_name 2>/dev/null || echo "none")

              if [[ "$service" =~ ^vault_web ]]; then
                if [ "$status" = "running" ] && ([ "$health" = "none" ] || [ "$health" = "healthy" ]); then
                  if [ ! -f "/tmp/${service}_start_time.txt" ]; then
                    echo "$current_time" > "/tmp/${service}_start_time.txt"
                  fi
                fi
              else
                if [ "$status" != "running" ] || ([ "$health" != "none" ] && [ "$health" != "healthy" ]); then
                  all_critical_healthy=false
                else
                  if [ ! -f "/tmp/${service}_start_time.txt" ]; then
                    echo "$current_time" > "/tmp/${service}_start_time.txt"
                  fi
                fi
              fi
            done

            if [ "$all_critical_healthy" = "true" ]; then
              echo "‚úÖ All critical services are healthy"
              break
            fi

            if [ $attempt -lt $max_attempts ]; then
              sleep 3
            fi
          done

          if [ "$all_critical_healthy" != "true" ]; then
            echo "‚ùå Some critical services failed to become healthy within the timeout period"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Container Status:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã All Services Logs (last 100 lines):"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs --tail=100 || true
            exit 1
          fi

          echo "Phase 2: Waiting for orchestrator to become healthy..."
          attempt=0
          orchestrator_healthy=false
          while [ $attempt -lt $max_attempts ] && [ "$orchestrator_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            orchestrator_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q orchestrator 2>/dev/null | head -n1)
            if [ -n "$orchestrator_container" ]; then
              status=$(docker inspect --format='{{.State.Status}}' $orchestrator_container 2>/dev/null || echo "unknown")
              health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $orchestrator_container 2>/dev/null || echo "none")

              if [ "$status" = "running" ] && ([ "$health" = "none" ] || [ "$health" = "healthy" ]); then
                orchestrator_healthy=true
                echo "‚úÖ Orchestrator is healthy"
                echo "$(date +%s)" > /tmp/orchestrator_start_time.txt
                break
              fi
            fi

            if [ $attempt -lt $max_attempts ]; then
              sleep 3
            fi
          done

          if [ "$orchestrator_healthy" != "true" ]; then
            echo "‚ùå Orchestrator failed to become healthy within the timeout period"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Container Status:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Orchestrator Logs (last 100 lines):"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs orchestrator --tail=100 || true
            exit 1
          fi

      - name: Stop orchestrator after health check
        run: |
          echo "Orchestrator is healthy. Waiting 3 seconds before stopping..."
          sleep 3

          echo "Stopping orchestrator..."
          docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" stop orchestrator

          orchestrator_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q orchestrator 2>/dev/null | head -n1)
          if [ -n "$orchestrator_container" ]; then
            sleep 1
            status=$(docker inspect --format='{{.State.Status}}' $orchestrator_container 2>/dev/null || echo "unknown")
            if [ "$status" != "exited" ] && [ "$status" != "stopped" ]; then
              echo "‚ùå Orchestrator failed to stop (status: $status)"
              exit 1
            fi
          fi

          echo "‚úÖ Orchestrator stopped successfully"
          echo "$(date +%s)" > /tmp/orchestrator_end_time.txt

      - name: Verify vault_web services stability
        run: |
          echo "Waiting for vault_web1 and vault_web2 to become healthy..."

          vault_web1_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q vault_web1 2>/dev/null | head -n1)
          vault_web2_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q vault_web2 2>/dev/null | head -n1)

          if [ -z "$vault_web1_container" ] || [ -z "$vault_web2_container" ]; then
            echo "‚ùå vault_web1 or vault_web2 container not found"
            echo "vault_web1: ${vault_web1_container:-not found}"
            echo "vault_web2: ${vault_web2_container:-not found}"
            exit 1
          fi

          max_attempts=20
          attempt=0
          vault_web_healthy=false

          while [ $attempt -lt $max_attempts ] && [ "$vault_web_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            vault_web1_status=$(docker inspect --format='{{.State.Status}}' $vault_web1_container 2>/dev/null || echo "unknown")
            vault_web1_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web1_container 2>/dev/null || echo "none")
            vault_web2_status=$(docker inspect --format='{{.State.Status}}' $vault_web2_container 2>/dev/null || echo "unknown")
            vault_web2_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web2_container 2>/dev/null || echo "none")

            if [ "$vault_web1_status" = "running" ] && ([ "$vault_web1_health" = "none" ] || [ "$vault_web1_health" = "healthy" ]) && \
               [ "$vault_web2_status" = "running" ] && ([ "$vault_web2_health" = "none" ] || [ "$vault_web2_health" = "healthy" ]); then
              vault_web_healthy=true
              echo "‚úÖ vault_web1 and vault_web2 are healthy"
              current_time=$(date +%s)
              if [ ! -f "/tmp/vault_web1_start_time.txt" ]; then
                echo "$current_time" > /tmp/vault_web1_start_time.txt
              fi
              if [ ! -f "/tmp/vault_web2_start_time.txt" ]; then
                echo "$current_time" > /tmp/vault_web2_start_time.txt
              fi
              break
            fi

            if [ $attempt -lt $max_attempts ]; then
              sleep 2
            fi
          done

          if [ "$vault_web_healthy" != "true" ]; then
            echo "‚ùå vault_web1 or vault_web2 failed to become healthy within the timeout period"
            echo "vault_web1: status=$vault_web1_status, health=$vault_web1_health"
            echo "vault_web2: status=$vault_web2_status, health=$vault_web2_health"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Container Status:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã vault_web1 Logs (last 100 lines):"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web1 --tail=100 || true
            exit 1
          fi

          echo "Waiting 3 seconds to verify stability..."
          sleep 3

          vault_web1_status=$(docker inspect --format='{{.State.Status}}' $vault_web1_container 2>/dev/null || echo "unknown")
          vault_web1_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web1_container 2>/dev/null || echo "none")
          vault_web2_status=$(docker inspect --format='{{.State.Status}}' $vault_web2_container 2>/dev/null || echo "unknown")
          vault_web2_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web2_container 2>/dev/null || echo "none")

          if [ "$vault_web1_status" != "running" ] || ([ "$vault_web1_health" != "none" ] && [ "$vault_web1_health" != "healthy" ]); then
            echo "‚ùå vault_web1 is no longer healthy after 3 seconds (status: $vault_web1_status, health: $vault_web1_health)"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Container Status:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã vault_web1 Logs (last 100 lines):"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web1 --tail=100 || true
            exit 1
          fi

          if [ "$vault_web2_status" != "running" ] || ([ "$vault_web2_health" != "none" ] && [ "$vault_web2_health" != "healthy" ]); then
            echo "‚ùå vault_web2 is no longer healthy after 3 seconds (status: $vault_web2_status, health: $vault_web2_health)"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Container Status:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã vault_web1 Logs (last 100 lines):"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web1 --tail=100 || true
            exit 1
          fi

          echo "‚úÖ vault_web1 and vault_web2 remained healthy for 3 seconds after orchestrator was stopped"
          end_time=$(date +%s)
          echo "$end_time" > /tmp/vault_web1_end_time.txt
          echo "$end_time" > /tmp/vault_web2_end_time.txt

          services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services)
          for service in $services; do
            if [ "$service" != "orchestrator" ] && [[ ! "$service" =~ ^vault_web ]]; then
              echo "$end_time" > "/tmp/${service}_end_time.txt"
            fi
          done

      - name: Health check duration summary
        if: always()
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìä HEALTH CHECK DURATION SUMMARY"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          printf "%-20s %-15s\n" "Container" "Duration"
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

          services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services 2>/dev/null || echo "")
          displayed_services=""

          for service in $services; do
            start_file="/tmp/${service}_start_time.txt"
            end_file="/tmp/${service}_end_time.txt"

            if [ -f "$start_file" ] && [ -f "$end_file" ]; then
              start_time=$(cat "$start_file")
              end_time=$(cat "$end_file")
              duration=$((end_time - start_time))

              if [ $duration -ge 0 ]; then
                minutes=$((duration / 60))
                seconds=$((duration % 60))

                if [ $minutes -gt 0 ]; then
                  duration_str="${minutes}m ${seconds}s"
                else
                  duration_str="${seconds}s"
                fi

                printf "%-20s %-15s\n" "$service" "$duration_str"
                displayed_services="${displayed_services} ${service}"
              else
                printf "%-20s %-15s\n" "$service" "N/A (invalid)"
                displayed_services="${displayed_services} ${service}"
              fi
            elif [ -f "$start_file" ]; then
              printf "%-20s %-15s\n" "$service" "N/A (no end time)"
              displayed_services="${displayed_services} ${service}"
            elif [ -f "$end_file" ]; then
              printf "%-20s %-15s\n" "$service" "N/A (no start time)"
              displayed_services="${displayed_services} ${service}"
            fi
          done

          for vault_service in vault_web1 vault_web2; do
            if echo "$displayed_services" | grep -q " ${vault_service} "; then
              continue
            fi

            start_file="/tmp/${vault_service}_start_time.txt"
            end_file="/tmp/${vault_service}_end_time.txt"

            if [ -f "$start_file" ] && [ -f "$end_file" ]; then
              start_time=$(cat "$start_file")
              end_time=$(cat "$end_file")
              duration=$((end_time - start_time))

              if [ $duration -ge 0 ]; then
                minutes=$((duration / 60))
                seconds=$((duration % 60))

                if [ $minutes -gt 0 ]; then
                  duration_str="${minutes}m ${seconds}s"
                else
                  duration_str="${seconds}s"
                fi

                printf "%-20s %-15s\n" "$vault_service" "$duration_str"
              else
                printf "%-20s %-15s\n" "$vault_service" "N/A (invalid duration)"
              fi
            elif [ -f "$start_file" ]; then
              printf "%-20s %-15s\n" "$vault_service" "N/A (no end time)"
            elif [ -f "$end_file" ]; then
              printf "%-20s %-15s\n" "$vault_service" "N/A (no start time)"
            else
              printf "%-20s %-15s\n" "$vault_service" "N/A (no timestamps)"
            fi
          done

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""

      - name: Cleanup
        if: always()
        run: |
          # Stop containers without removing volumes (safety: volumes are removed manually with filters)
          docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" down || true

          # Remove containers, volumes, and networks ONLY if they match the project prefix
          # This ensures we never accidentally delete production resources
          PROJECT_PREFIX="${COMPOSE_PROJECT_NAME}-"

          # Remove containers with project prefix
          docker ps -a --format "{{.Names}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker rm -f 2>/dev/null || true

          # Remove volumes with project prefix ONLY (never delete production volumes)
          docker volume ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker volume rm 2>/dev/null || true

          # Remove networks with project prefix
          docker network ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker network rm 2>/dev/null || true

          # Additional safety: verify no production volumes were affected
          # Check if any volumes starting with "leyzen-" (without prefix) were deleted
          # This should never happen if prefixing worked correctly
          echo "‚úÖ Cleanup complete. Only resources with prefix '${PROJECT_PREFIX}' were removed."
