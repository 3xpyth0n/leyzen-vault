name: Health Check

permissions:
  contents: read

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  health-check:
    name: Container health check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      COMPOSE_PROJECT_NAME: leyzen-vault-github-action-${{ github.run_id || format('local-{0}', github.run_attempt) }}
      PHASE1_MAX_ATTEMPTS: 20
      PHASE1_SLEEP_SECONDS: 2
      PHASE2_MAX_ATTEMPTS: 15
      PHASE2_SLEEP_SECONDS: 2
      VAULT_MAX_ATTEMPTS: 15
      VAULT_SLEEP_SECONDS: 1
      SUMMARY_ENABLE: true

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24.9"

      - name: Record job start time
        run: |
          echo "JOB_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: Build CLI
        run: |
          cd tools/cli
          go build -o ../../leyzenctl .

      - name: Clean up action-specific Docker resources
        run: |
          PROJECT_PREFIX="leyzen-vault-github-action-"
          docker ps -a --format "{{.Names}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker rm -f 2>/dev/null || true
          docker volume ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker volume rm 2>/dev/null || true
          docker network ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker network rm 2>/dev/null || true

      - name: Create .env file with minimal configuration
        run: |
          # Remove any existing .env files that might interfere
          rm -f .env .env.health-check
          find . -maxdepth 2 -name ".env*" -type f -delete || true

          # Generate secrets
          SECRET_KEY=$(openssl rand -hex 32)
          POSTGRES_PASSWORD=$(openssl rand -hex 32)

          # Create health-check specific .env file with explicit name
          # This file will be referenced via LEYZEN_ENV_FILE to ensure isolation
          {
            echo "ORCHESTRATOR_ENABLED=true"
            echo "LEYZEN_ENVIRONMENT=dev"
            echo "ORCH_USER=test_user"
            echo "ORCH_PASS=test_pass"
            echo "HTTP_PORT=12345"
            echo "SECRET_KEY=${SECRET_KEY}"
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
            echo "WEB_REPLICAS=2"
            echo "TIMEZONE=UTC"
            echo "PROXY_TRUST_COUNT=1"
            echo "SESSION_COOKIE_SECURE=false"
            echo "POSTGRES_DB=leyzen_vault"
            echo "POSTGRES_USER=leyzen"
          } > .env.health-check

      - name: Generate docker-generated.yml
        run: |
          rm -f docker-generated.yml

          # Use LEYZEN_ENV_FILE to explicitly point to the health-check environment file
          # This ensures leyzenctl uses the correct .env file and prevents production
          # environment variables from leaking into the test environment
          export LEYZEN_ENV_FILE=.env.health-check

          ./leyzenctl config generate

          if [ ! -f docker-generated.yml ]; then
            echo "[ERROR] docker-generated.yml was not created!"
            exit 1
          fi

          # Verify orchestrator is enabled (vault_app should NOT exist, vault_web1 should exist)
          if docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^vault_app$"; then
            echo "[ERROR] vault_app found (orchestrator appears to be disabled)"
            exit 1
          fi

          if ! docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^vault_web1$"; then
            echo "[ERROR] vault_web containers not found"
            exit 1
          fi

          if ! docker compose -f docker-generated.yml config --services 2>/dev/null | grep -q "^orchestrator$"; then
            echo "[ERROR] orchestrator service not found"
            exit 1
          fi

      - name: Prefix volumes, networks, and containers with project name
        run: |
          python3 << PYEOF
          import re
          import os
          import sys

          yaml_file = "docker-generated.yml"
          project_prefix = os.environ.get("COMPOSE_PROJECT_NAME", "leyzen-vault-github-action") + "-"

          with open(yaml_file, 'r') as f:
              content = f.read()

          original_content = content

          # Prefix volume names
          content = re.sub(
              r'(\s+name:\s+)(["\']?)([^"\'\s]+)\2',
              lambda m: f'{m.group(1)}{m.group(2)}{project_prefix}{m.group(3)}{m.group(2)}'
              if not m.group(3).startswith(project_prefix) else m.group(0),
              content
          )

          # Prefix container names
          content = re.sub(
              r'(\s+container_name:\s+)(["\']?)([^"\'\s]+)\2',
              lambda m: f'{m.group(1)}{m.group(2)}{project_prefix}{m.group(3)}{m.group(2)}'
              if not m.group(3).startswith(project_prefix) else m.group(0),
              content
          )

          # Prefix network names
          unprefixed = re.findall(r'(\s+(?:container_name|name):\s+)(["\']?)([^"\'\s]+)\2', content)
          unprefixed = [
              match for match in unprefixed
              if not match[2].startswith(project_prefix)
          ]
          if unprefixed:
              print(f"[ERROR] Found {len(unprefixed)} unprefixed resources:", file=sys.stderr)
              for match in unprefixed:
                  print(f"  - {match[2]}", file=sys.stderr)
              print("All resources must be prefixed to prevent accidental interference with production!", file=sys.stderr)
              sys.exit(1)

          with open(yaml_file, 'w') as f:
              f.write(content)

          print(f"Successfully prefixed all volumes, networks, and containers with '{project_prefix}'")
          PYEOF

      - name: Build and start containers
        run: |
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" pull || true
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" build --no-cache
          set +e
          docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" up -d
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "[ERROR] docker compose up failed (exit code: $rc)"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "[NOTE] Container Status:"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" ps || true
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "[NOTE] HAProxy diagnostics (last 200 lines):"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" logs haproxy --tail=200 || true
            haproxy_container=$(docker compose -f docker-generated.yml -p "$COMPOSE_PROJECT_NAME" ps -q haproxy 2>/dev/null | head -n1)
            if [ -n "$haproxy_container" ]; then
              echo ""
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "[NOTE] haproxy -c validation output:"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              docker exec "$haproxy_container" haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg || true
            fi
            exit $rc
          fi

      - name: Phase 1 - wait for containers to be running
        run: |
          max_attempts=${PHASE1_MAX_ATTEMPTS:-20}
          attempt=0

          echo "Phase 1: Waiting for critical services to be running..."
          attempt=0
          all_critical_healthy=false

          while [ $attempt -lt $max_attempts ] && [ "$all_critical_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services)
            all_critical_healthy=true
            current_time=$(date +%s)

            for service in $services; do
              if [ "$service" = "orchestrator" ]; then
                continue
              fi

              container_name=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q $service 2>/dev/null | head -n1)
              if [ -z "$container_name" ]; then
                if [[ ! "$service" =~ ^vault_web ]]; then
                  all_critical_healthy=false
                fi
                continue
              fi

              status=$(docker inspect --format='{{.State.Status}}' $container_name 2>/dev/null || echo "unknown")
              health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $container_name 2>/dev/null || echo "none")

              if [ "$status" = "running" ]; then
                if [ ! -f "/tmp/${service}_start_time.txt" ]; then
                  echo "$current_time" > "/tmp/${service}_start_time.txt"
                fi
              else
                all_critical_healthy=false
              fi
            done

            if [ "$all_critical_healthy" = "true" ]; then
              echo "All critical services are running"
              break
            fi

            sleep ${PHASE1_SLEEP_SECONDS:-2}
          done

          if [ "$all_critical_healthy" != "true" ]; then
            echo "[ERROR] Some critical services failed to reach running state within the timeout"
            echo "Container Status:"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps || true
            echo "Collecting logs for failed services only..."
            services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services)
            for service in $services; do
              [ "$service" = "orchestrator" ] && continue
              container_name=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q $service 2>/dev/null | head -n1)
              [ -z "$container_name" ] && continue
              status=$(docker inspect --format='{{.State.Status}}' $container_name 2>/dev/null || echo "unknown")
              if [ "$status" != "running" ]; then
                docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs "$service" --tail=200 || true
              fi
            done
            exit 1
          fi

          echo "Phase 2: Waiting for orchestrator minimal readiness..."
          attempt=0
          orchestrator_healthy=false
          while [ $attempt -lt $max_attempts ] && [ "$orchestrator_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            orchestrator_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q orchestrator 2>/dev/null | head -n1)
            if [ -n "$orchestrator_container" ]; then
              status=$(docker inspect --format='{{.State.Status}}' $orchestrator_container 2>/dev/null || echo "unknown")
              health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $orchestrator_container 2>/dev/null || echo "none")

              if [ "$status" = "running" ] && ([ "$health" = "none" ] || [ "$health" = "healthy" ]); then
                # Verify login page returns 200 and contains expected HTML
                if docker exec "$orchestrator_container" curl -f -s http://localhost/orchestrator/login | grep -q "Leyzen Orchestrator"; then
                  orchestrator_healthy=true
                  echo "Orchestrator is healthy and login page is accessible internally"
                  echo "$(date +%s)" > /tmp/orchestrator_start_time.txt
                  break
                else
                  echo "[WAIT] Orchestrator container is running but login page is not yet accessible internally or content is incorrect"
                fi
              fi
            fi

            sleep ${PHASE2_SLEEP_SECONDS:-2}
          done

          if [ "$orchestrator_healthy" != "true" ]; then
            echo "[ERROR] Orchestrator failed to become healthy within the timeout period"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Container Status:"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Orchestrator Logs (last 100 lines):"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs orchestrator --tail=100 || true
            exit 1
          fi

      - name: Stop orchestrator after health check
        run: |
          echo "Orchestrator is healthy. Waiting 3 seconds before stopping..."
          sleep 3

          echo "Stopping orchestrator..."
          docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" stop orchestrator

          orchestrator_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q orchestrator 2>/dev/null | head -n1)
          if [ -n "$orchestrator_container" ]; then
            sleep 1
            status=$(docker inspect --format='{{.State.Status}}' $orchestrator_container 2>/dev/null || echo "unknown")
            if [ "$status" != "exited" ] && [ "$status" != "stopped" ]; then
              echo "[ERROR] Orchestrator failed to stop (status: $status)"
              exit 1
            fi
          fi

          echo "Orchestrator stopped successfully"
          echo "$(date +%s)" > /tmp/orchestrator_end_time.txt

      - name: Verify vault_web services stability
        run: |
          echo "Waiting for vault_web1 and vault_web2 to become healthy..."

          vault_web1_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q vault_web1 2>/dev/null | head -n1)
          vault_web2_container=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q vault_web2 2>/dev/null | head -n1)

          if [ -z "$vault_web1_container" ] || [ -z "$vault_web2_container" ]; then
            echo "[ERROR] vault_web1 or vault_web2 container not found"
            echo "vault_web1: ${vault_web1_container:-not found}"
            echo "vault_web2: ${vault_web2_container:-not found}"
            exit 1
          fi

          max_attempts=${VAULT_MAX_ATTEMPTS:-15}
          attempt=0
          vault_web_healthy=false

          while [ $attempt -lt $max_attempts ] && [ "$vault_web_healthy" != "true" ]; do
            attempt=$((attempt + 1))

            vault_web1_status=$(docker inspect --format='{{.State.Status}}' $vault_web1_container 2>/dev/null || echo "unknown")
            vault_web1_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web1_container 2>/dev/null || echo "none")
            vault_web2_status=$(docker inspect --format='{{.State.Status}}' $vault_web2_container 2>/dev/null || echo "unknown")
            vault_web2_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web2_container 2>/dev/null || echo "none")

            if [ "$vault_web1_status" = "running" ] && ([ "$vault_web1_health" = "none" ] || [ "$vault_web1_health" = "healthy" ]) && \
               [ "$vault_web2_status" = "running" ] && ([ "$vault_web2_health" = "none" ] || [ "$vault_web2_health" = "healthy" ]); then
              # Verify setup page returns 200 and contains expected HTML for both containers internally
              if docker exec "$vault_web1_container" curl -f -s http://localhost/setup | grep -q "Leyzen Vault" && \
                 docker exec "$vault_web2_container" curl -f -s http://localhost/setup | grep -q "Leyzen Vault"; then
                vault_web_healthy=true
                echo "vault_web1 and vault_web2 are healthy and setup page is accessible internally"
                current_time=$(date +%s)
                if [ ! -f "/tmp/vault_web1_start_time.txt" ]; then
                  echo "$current_time" > /tmp/vault_web1_start_time.txt
                fi
                if [ ! -f "/tmp/vault_web2_start_time.txt" ]; then
                  echo "$current_time" > /tmp/vault_web2_start_time.txt
                fi
                break
              else
                echo "[WAIT] vault_web containers are running but setup page is not yet accessible internally or content is incorrect"
              fi
            fi

            sleep ${VAULT_SLEEP_SECONDS:-1}
          done

          if [ "$vault_web_healthy" != "true" ]; then
            echo "[ERROR] vault_web1 or vault_web2 failed to become healthy within the timeout period"
            echo "vault_web1: status=$vault_web1_status, health=$vault_web1_health"
            echo "vault_web2: status=$vault_web2_status, health=$vault_web2_health"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "[NOTE] Container Status:"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "Collecting logs for failed vault_web containers..."
            if [ "$vault_web1_status" != "running" ] || ([ "$vault_web1_health" != "none" ] && [ "$vault_web1_health" != "healthy" ]); then
              docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web1 --tail=200 || true
            fi
            if [ "$vault_web2_status" != "running" ] || ([ "$vault_web2_health" != "none" ] && [ "$vault_web2_health" != "healthy" ]); then
              docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web2 --tail=200 || true
            fi
            exit 1
          fi

          echo "Waiting 3 seconds to verify stability..."
          sleep 3

          vault_web1_status=$(docker inspect --format='{{.State.Status}}' $vault_web1_container 2>/dev/null || echo "unknown")
          vault_web1_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web1_container 2>/dev/null || echo "none")
          vault_web2_status=$(docker inspect --format='{{.State.Status}}' $vault_web2_container 2>/dev/null || echo "unknown")
          vault_web2_health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $vault_web2_container 2>/dev/null || echo "none")

          if [ "$vault_web1_status" != "running" ] || ([ "$vault_web1_health" != "none" ] && [ "$vault_web1_health" != "healthy" ]); then
            echo "[ERROR] vault_web1 is no longer healthy after 3 seconds (status: $vault_web1_status, health: $vault_web1_health)"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Container Status:"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "vault_web1 Logs (last 100 lines):"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web1 --tail=100 || true
            exit 1
          fi

          if [ "$vault_web2_status" != "running" ] || ([ "$vault_web2_health" != "none" ] && [ "$vault_web2_health" != "healthy" ]); then
            echo "[ERROR] vault_web2 is no longer healthy after 3 seconds (status: $vault_web2_status, health: $vault_web2_health)"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Container Status:"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "vault_web2 Logs (last 100 lines):"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs vault_web2 --tail=100 || true
            exit 1
          fi

          # Final verification of setup page accessibility internally
          if ! docker exec "$vault_web1_container" curl -f -s http://localhost/setup | grep -q "Leyzen Vault"; then
            echo "[ERROR] vault setup page is no longer accessible internally after 3 seconds"
            exit 1
          fi

          echo "vault_web1 and vault_web2 remained healthy for 3 seconds after orchestrator was stopped"
          end_time=$(date +%s)
          echo "$end_time" > /tmp/vault_web1_end_time.txt
          echo "$end_time" > /tmp/vault_web2_end_time.txt

          services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services)
          for service in $services; do
            if [ "$service" != "orchestrator" ] && [[ ! "$service" =~ ^vault_web ]]; then
              echo "$end_time" > "/tmp/${service}_end_time.txt"
            fi
          done

      - name: Health check duration summary
        if: always()
        run: |
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "HEALTH CHECK DURATION SUMMARY"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          printf "%-20s %-15s\n" "Container" "Duration"
          echo "────────────────────────────────────────────────────"

          services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services 2>/dev/null || echo "")
          displayed_services=""
          earliest_start=""
          latest_end=""

          for service in $services; do
            start_file="/tmp/${service}_start_time.txt"
            end_file="/tmp/${service}_end_time.txt"

            if [ -f "$start_file" ] && [ -f "$end_file" ]; then
              start_time=$(cat "$start_file")
              end_time=$(cat "$end_file")
              duration=$((end_time - start_time))

              if [ $duration -ge 0 ]; then
                minutes=$((duration / 60))
                seconds=$((duration % 60))

                if [ $minutes -gt 0 ]; then
                  duration_str="${minutes}m ${seconds}s"
                else
                  duration_str="${seconds}s"
                fi

                printf "%-20s %-15s\n" "$service" "$duration_str"
                displayed_services="${displayed_services} ${service}"
                if [ -z "$earliest_start" ] || [ $start_time -lt $earliest_start ]; then
                  earliest_start=$start_time
                fi
                if [ -z "$latest_end" ] || [ $end_time -gt $latest_end ]; then
                  latest_end=$end_time
                fi
              else
                printf "%-20s %-15s\n" "$service" "N/A (invalid)"
                displayed_services="${displayed_services} ${service}"
              fi
            elif [ -f "$start_file" ]; then
              printf "%-20s %-15s\n" "$service" "N/A (no end time)"
              displayed_services="${displayed_services} ${service}"
            elif [ -f "$end_file" ]; then
              printf "%-20s %-15s\n" "$service" "N/A (no start time)"
              displayed_services="${displayed_services} ${service}"
            fi
          done

          for vault_service in vault_web1 vault_web2; do
            if echo "$displayed_services" | grep -qE "(^|[[:space:]])${vault_service}([[:space:]]|$)"; then
              continue
            fi

            start_file="/tmp/${vault_service}_start_time.txt"
            end_file="/tmp/${vault_service}_end_time.txt"

            if [ -f "$start_file" ] && [ -f "$end_file" ]; then
              start_time=$(cat "$start_file")
              end_time=$(cat "$end_file")
              duration=$((end_time - start_time))

              if [ $duration -ge 0 ]; then
                minutes=$((duration / 60))
                seconds=$((duration % 60))

                if [ $minutes -gt 0 ]; then
                  duration_str="${minutes}m ${seconds}s"
                else
                  duration_str="${seconds}s"
                fi

                printf "%-20s %-15s\n" "$vault_service" "$duration_str"
                if [ -z "$earliest_start" ] || [ $start_time -lt $earliest_start ]; then
                  earliest_start=$start_time
                fi
                if [ -z "$latest_end" ] || [ $end_time -gt $latest_end ]; then
                  latest_end=$end_time
                fi
              else
                printf "%-20s %-15s\n" "$vault_service" "N/A (invalid duration)"
              fi
            elif [ -f "$start_file" ]; then
              printf "%-20s %-15s\n" "$vault_service" "N/A (no end time)"
            elif [ -f "$end_file" ]; then
              printf "%-20s %-15s\n" "$vault_service" "N/A (no start time)"
            else
              printf "%-20s %-15s\n" "$vault_service" "N/A (no timestamps)"
            fi
          done

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          if [ -n "${JOB_START_TIME:-}" ]; then
            total_duration=$(( $(date +%s) - JOB_START_TIME ))
            tmin=$((total_duration / 60))
            tsec=$((total_duration % 60))
            echo "Total Action Duration: ${tmin}m ${tsec}s"
          elif [ -n "$earliest_start" ] && [ -n "$latest_end" ]; then
            total_duration=$((latest_end - earliest_start))
            tmin=$((total_duration / 60))
            tsec=$((total_duration % 60))
            echo "Total Action Duration: ${tmin}m ${tsec}s"
          fi
          echo ""

      - name: Collect diagnostics on failure
        if: failure()
        run: |
          mkdir -p diagnostics
          services=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" config --services 2>/dev/null || echo "")
          for service in $services; do
            container_name=$(docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" ps -q $service 2>/dev/null | head -n1)
            [ -z "$container_name" ] && continue
            status=$(docker inspect --format='{{.State.Status}}' $container_name 2>/dev/null || echo "unknown")
            health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' $container_name 2>/dev/null || echo "none")
            if [ "$status" != "running" ] || ([ "$health" != "none" ] && [ "$health" != "healthy" ]); then
              docker inspect "$container_name" > "diagnostics/${service}-inspect.json" 2>/dev/null || true
              docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" logs "$service" --tail=200 > "diagnostics/${service}-logs.txt" 2>/dev/null || true
            fi
          done
          cp docker-generated.yml diagnostics/ 2>/dev/null || true
          [ -f infra/haproxy/haproxy.cfg ] && cp infra/haproxy/haproxy.cfg diagnostics/ || true

      - name: Upload diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: health-check-diagnostics
          path: diagnostics

      - name: Cleanup
        if: always()
        run: |
          # Stop containers without removing volumes (safety: volumes are removed manually with filters)
          docker compose -f docker-generated.yml -p "${COMPOSE_PROJECT_NAME}" down || true

          # Remove containers, volumes, and networks ONLY if they match the project prefix
          # This ensures we never accidentally delete production resources
          PROJECT_PREFIX="${COMPOSE_PROJECT_NAME}-"

          # Remove containers with project prefix
          docker ps -a --format "{{.Names}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker rm -f 2>/dev/null || true

          # Remove volumes with project prefix ONLY (never delete production volumes)
          docker volume ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker volume rm 2>/dev/null || true

          # Remove networks with project prefix
          docker network ls --format "{{.Name}}" | grep "^${PROJECT_PREFIX}" | xargs -r docker network rm 2>/dev/null || true

          # Additional safety: verify no production volumes were affected
          # Check if any volumes starting with "leyzen-" (without prefix) were deleted
          # This should never happen if prefixing worked correctly
          echo "Cleanup complete. Only resources with prefix '${PROJECT_PREFIX}' were removed."
