name: CI
permissions:
  contents: read

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  syntax-check:
    name: Python syntax check
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r src/orchestrator/requirements.txt
          pip install -r infra/docker-proxy/requirements.txt
          pip install ruff black

      - name: Validate Python bytecode
        run: python -m compileall src/orchestrator infra/docker-proxy src/compose src/vault

      - name: Ruff lint
        run: ruff check --select F401 src/orchestrator infra/docker-proxy src/compose

      - name: Check requirements version consistency
        run: |
          echo "üîç Checking requirements.txt version consistency..."
          python - <<'EOF'
          import re
          from pathlib import Path

          # Common dependencies that should have identical versions
          COMMON_DEPS = ["flask", "httpx", "uvicorn"]

          def extract_version(package_name: str, requirements_file: Path) -> str | None:
              """Extract version for a package from requirements.txt."""
              if not requirements_file.exists():
                  return None
              pattern = re.compile(rf"^{re.escape(package_name)}==([^#\s]+)", re.MULTILINE)
              with open(requirements_file) as f:
                  content = f.read()
                  match = pattern.search(content)
                  return match.group(1) if match else None

          orchestrator_req = Path("src/orchestrator/requirements.txt")
          docker_proxy_req = Path("infra/docker-proxy/requirements.txt")

          inconsistencies = []
          for dep in COMMON_DEPS:
              orch_ver = extract_version(dep, orchestrator_req)
              proxy_ver = extract_version(dep, docker_proxy_req)
              if orch_ver and proxy_ver and orch_ver != proxy_ver:
                  inconsistencies.append(f"{dep}: orchestrator={orch_ver}, docker-proxy={proxy_ver}")

          if inconsistencies:
              print("‚ùå Version inconsistencies found:")
              for inc in inconsistencies:
                  print(f"  - {inc}")
              exit(1)
          else:
              print("‚úÖ All common dependencies have consistent versions.")
          EOF

      - name: Check Prettier formatting
        run: npx prettier --check .

      - name: Check Black formatting
        run: black --check .

  shellcheck:
    name: Shell script linting
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Run shellcheck
        uses: ludeeus/action-shellcheck@master
        with:
          scandir: "."
          format: gcc
          severity: error
          shell: bash

  secret-scan:
    name: Secret scanning
    runs-on: ubuntu-latest
    env:
      GIT_DISCOVERY_ACROSS_FILESYSTEM: 1
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure git repository is initialized
        run: |
          if [ ! -d .git ]; then
            echo "Git repository not found. Checking possible locations..."
            # Try to find .git in common act locations
            if [ -d "/github/workspace/.git" ]; then
              echo "Found .git in /github/workspace, copying..."
              cp -r /github/workspace/.git .git || true
            fi
            # Try current directory's parent (where act might mount it)
            if [ ! -d .git ] && [ -d "$(dirname $(pwd))/.git" ]; then
              echo "Found .git in parent directory, copying..."
              cp -r "$(dirname $(pwd))/.git" .git || true
            fi
            # For act: try to copy from the host path
            if [ ! -d .git ] && [ -n "$GITHUB_WORKSPACE" ]; then
              HOST_PATH="${GITHUB_WORKSPACE}"
              if [ -d "${HOST_PATH}/.git" ]; then
                echo "Found .git in GITHUB_WORKSPACE, copying..."
                cp -r "${HOST_PATH}/.git" .git || true
              fi
            fi
            # Last resort: initialize a new repo (will only work for basic checks)
            if [ ! -d .git ]; then
              echo "Warning: Could not find .git, initializing new repository..."
              echo "This may limit TruffleHog's ability to scan commit history."
              git init
              git config user.name "act"
              git config user.email "act@localhost"
              git add .
              git commit -m "Initial commit for act" || true
              git branch -M main || true
            fi
          fi
          # Verify git is working
          git status || echo "Warning: git status failed"
          git log --oneline -1 || echo "Warning: git log failed"

      - name: Run TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event_name == 'push' && github.event.before || (github.event_name == 'pull_request' && github.event.pull_request.base.sha || '') }}
          head: ${{ github.event_name == 'push' && github.event.after || (github.event_name == 'pull_request' && github.event.pull_request.head.sha || 'HEAD') }}

  runtime-check:
    name: Runtime import validation
    runs-on: ubuntu-latest
    needs: syntax-check
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r src/orchestrator/requirements.txt
          pip install -r infra/docker-proxy/requirements.txt

      - name: Verify imports and module loading
        run: |
          echo "üîç Checking all modules can be imported..."
          python - <<'EOF'
          import importlib
          import importlib.util
          import pathlib
          import sys

          # Add src/ to PYTHONPATH to enable imports like 'from common.constants import ...'
          src_dir = pathlib.Path("src")
          if src_dir.exists():
              src_path = str(src_dir.resolve())
              if src_path not in sys.path:
                  sys.path.insert(0, src_path)

          # Add repo root to PYTHONPATH to enable imports from infra/ modules
          repo_root = pathlib.Path(".").resolve()
          repo_root_str = str(repo_root)
          if repo_root_str not in sys.path:
              sys.path.insert(0, repo_root_str)

          paths = ["src/orchestrator", "infra/docker-proxy", "src/compose", "src/common"]
          for p in paths:
              pkg_path = pathlib.Path(p)
              if pkg_path.exists():
                  for pyfile in pkg_path.rglob("*.py"):
                      parts = pyfile.with_suffix("").parts
                      
                      # Check if this is a module that can't be imported normally (e.g., has hyphens)
                      # For modules in infra/docker-proxy, use spec_from_file_location
                      if parts[0] == "infra" and "docker-proxy" in parts:
                          # Use importlib.util for modules with hyphens in path
                          print(f"‚Üí Loading {pyfile}")
                          try:
                              spec = importlib.util.spec_from_file_location("_temp_module", pyfile)
                              if spec is None or spec.loader is None:
                                  print(f"‚ùå Failed to create spec for {pyfile}")
                                  sys.exit(1)
                              module = importlib.util.module_from_spec(spec)
                              spec.loader.exec_module(module)
                          except Exception as e:
                              print(f"‚ùå Failed to load {pyfile}: {e}")
                              sys.exit(1)
                      elif parts[0] == "src":
                          # Remove 'src' prefix: src/orchestrator/__init__.py -> orchestrator.__init__
                          modname = ".".join(parts[1:])
                          print(f"‚Üí Importing {modname}")
                          try:
                              importlib.import_module(modname)
                          except Exception as e:
                              print(f"‚ùå Failed to import {modname}: {e}")
                              sys.exit(1)
                      else:
                          # Fallback: try to import with full path
                          modname = ".".join(parts)
                          print(f"‚Üí Importing {modname}")
                          try:
                              importlib.import_module(modname)
                          except Exception as e:
                              print(f"‚ùå Failed to import {modname}: {e}")
                              sys.exit(1)
          print("‚úÖ All modules imported successfully.")
          EOF
